<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DanielLee</title>
  
  <subtitle>这一刻 与你相遇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://luckystart.xyz/"/>
  <updated>2020-02-17T11:22:29.087Z</updated>
  <id>https://luckystart.xyz/</id>
  
  <author>
    <name>李思远</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识TypeScript</title>
    <link href="https://luckystart.xyz/2020/02/17/chu-shi-typescript/"/>
    <id>https://luckystart.xyz/2020/02/17/chu-shi-typescript/</id>
    <published>2020-02-17T11:22:29.000Z</published>
    <updated>2020-02-17T11:22:29.087Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React路由</title>
    <link href="https://luckystart.xyz/2020/02/17/react-lu-you/"/>
    <id>https://luckystart.xyz/2020/02/17/react-lu-you/</id>
    <published>2020-02-17T06:36:34.000Z</published>
    <updated>2020-02-17T14:14:15.492Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h3><h4 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h4><blockquote><p>根据不同的url切换组件，因为app是浏览器上跑的，所以在web上切换页面要刷新，影响用户体验，所以提出了前端路由，通过前端的路由映射关系来匹配，不会再发起请求</p></blockquote><h4 id="后端路由"><a href="#后端路由" class="headerlink" title="后端路由"></a>后端路由</h4><blockquote><p>根据用户的请求返回不同的内容，由后端直接把页面返回，如果访问人数过多，容易给服务器造成很大的压力</p></blockquote><h3 id="React路由-V5版本"><a href="#React路由-V5版本" class="headerlink" title="React路由      V5版本"></a>React路由      V5版本</h3><blockquote><p>官网：  <a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener">https://reacttraining.com/react-router/web/guides/quick-start</a> </p><p>中文网：  <a href="https://react-router.docschina.org/" target="_blank" rel="noopener">https://react-router.docschina.org/</a> </p></blockquote><pre class=" language-js"><code class="language-js">yarn add react<span class="token operator">-</span>router<span class="token operator">-</span>dom</code></pre><p>下载完成后启动项目，或者使用npm也可以下载</p><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>在index.js路口文件导入</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> BrowserRouter <span class="token keyword">as</span> Router <span class="token punctuation">}</span> <span class="token keyword">from</span> react<span class="token operator">-</span>router<span class="token operator">-</span>dom</code></pre><blockquote><p>路由有两种模式： </p><p>​    hash模式（#） HashRouter  通过监听不同的hash值来改变路由   推荐使用</p><p>​    历史记录模式（history） BrowserRouter 刷新需要重新配置请求</p></blockquote><p>然后利用Router将<App/> 包裹</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>Router<span class="token operator">></span>   <span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">></span> <span class="token operator">&lt;</span><span class="token operator">/</span>Router<span class="token operator">></span></code></pre><p>注意： 路由包裹了App，内部通过context向App的子孙组件去传值，关于context这里不提，可以看另一篇博客React的context</p><h4 id="组件切换"><a href="#组件切换" class="headerlink" title="组件切换"></a>组件切换</h4><p>先创建两个组件，然后将组件引入</p><p>home组件和Two组件，代码如下</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//home组件</span><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">index</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>        Home      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//two组件</span><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Two</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>        Two      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后在App里面将两个组件引入，然后再引入路由，创建无状态组件404页面，</p><blockquote><p>Switch, Route, NavLink, Redirect, Nav 都是react-router-dom 中的， 注意： exact  表示精确匹配，只有与路径完全一致才会匹配，NavLink和Nav 的区别是前面点击可以加样式，Switch 表示只会显示一个路由，Redirect表示重定向，输入 / 的时候重定向到 /home</p></blockquote><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>Route path<span class="token operator">=</span><span class="token string">"路径"</span> component<span class="token operator">=</span><span class="token punctuation">{</span>组件<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>Link to<span class="token operator">=</span><span class="token string">"路径"</span><span class="token operator">></span>点击名<span class="token operator">&lt;</span>Link<span class="token operator">></span><span class="token operator">&lt;</span>Redirect <span class="token keyword">from</span><span class="token operator">=</span><span class="token string">"/"</span> to<span class="token operator">=</span><span class="token string">"/test"</span> exact <span class="token operator">/</span><span class="token operator">></span></code></pre><p>完整代码如下</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">'./App.css'</span><span class="token punctuation">;</span><span class="token keyword">import</span> Home <span class="token keyword">from</span> <span class="token string">"./components/home/index"</span><span class="token keyword">import</span> Two <span class="token keyword">from</span> <span class="token string">"./components/two/Two"</span><span class="token keyword">import</span> <span class="token punctuation">{</span> Switch<span class="token punctuation">,</span> Route<span class="token punctuation">,</span> NavLink<span class="token punctuation">,</span> Redirect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"react-router-dom"</span><span class="token keyword">let</span> notFind <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>div<span class="token operator">></span><span class="token number">404</span>啊<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">"App"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>NavLink to<span class="token operator">=</span><span class="token string">"/home"</span><span class="token operator">></span>home<span class="token operator">&lt;</span><span class="token operator">/</span>NavLink<span class="token operator">></span>      <span class="token operator">&lt;</span>NavLink to<span class="token operator">=</span><span class="token string">"/two"</span><span class="token operator">></span>two<span class="token operator">&lt;</span><span class="token operator">/</span>NavLink<span class="token operator">></span>      <span class="token operator">&lt;</span>Switch<span class="token operator">></span>        <span class="token operator">&lt;</span>Route path<span class="token operator">=</span><span class="token string">"/home"</span> component<span class="token operator">=</span><span class="token punctuation">{</span>Home<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>        <span class="token operator">&lt;</span>Route path<span class="token operator">=</span><span class="token string">"/two"</span> component<span class="token operator">=</span><span class="token punctuation">{</span>Two<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>        <span class="token operator">&lt;</span>Redirect <span class="token keyword">from</span><span class="token operator">=</span><span class="token string">"/"</span> to<span class="token operator">=</span><span class="token string">"/home"</span> exact <span class="token operator">/</span><span class="token operator">></span>        <span class="token operator">&lt;</span>Route component<span class="token operator">=</span><span class="token punctuation">{</span>notFind<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>Switch<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">default</span> App<span class="token punctuation">;</span></code></pre><h3 id="this-props-children"><a href="#this-props-children" class="headerlink" title="this.props.children"></a>this.props.children</h3><blockquote><p>this.props.children   可以渲染子组件  类似于vue的插槽</p><p>&lt;组件&gt;</p><p>​    &lt;子组件&gt;</p><p>&lt;/组件&gt;</p><p>this.props.children如果有一个子组件，则是一个对象，如果是多个子组件，则是一个数组，没有则是undefined</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是路由&quot;&gt;&lt;a href=&quot;#什么是路由&quot; class=&quot;headerlink&quot; title=&quot;什么是路由&quot;&gt;&lt;/a&gt;什么是路由&lt;/h3&gt;&lt;h4 id=&quot;前端路由&quot;&gt;&lt;a href=&quot;#前端路由&quot; class=&quot;headerlink&quot; title=&quot;前端路由&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React的非父子传值</title>
    <link href="https://luckystart.xyz/2020/02/17/react-de-fei-fu-zi-chuan-zhi/"/>
    <id>https://luckystart.xyz/2020/02/17/react-de-fei-fu-zi-chuan-zhi/</id>
    <published>2020-02-17T06:13:08.000Z</published>
    <updated>2020-02-17T13:25:37.501Z</updated>
    
    <content type="html"><![CDATA[<p>react的父子组件传值大家都已经会了，今天我们来聊聊React的非父子组件传值，他的核心理念就是利用了发布订阅者模式来实现的，到最后，带大家手写一个发布订阅模式来实现react传值</p><h3 id="利用pubsub-js"><a href="#利用pubsub-js" class="headerlink" title="利用pubsub-js"></a>利用pubsub-js</h3><blockquote><p>pubsub-js 是别人已经封装好的一个库，只需要在项目中下载就可以使用，下面带来演示一下基本用法</p></blockquote><p>例如我们有两个组件，one组件和two组件，现在我们利用这个库来实现两个组件之间的传值</p><p>首先引入<em>pubsub-js</em> 在one组件里面</p><blockquote><p>利用 PubSub.publish(“事件名”, “要传的数据”)来创建</p></blockquote><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token comment" spellcheck="true">//引入pubsub-js</span><span class="token keyword">import</span> PubSub <span class="token keyword">from</span> <span class="token string">"pubsub-js"</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">One</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>  send <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    PubSub<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span><span class="token string">"evtBus"</span><span class="token punctuation">,</span> <span class="token string">"hello word"</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>send<span class="token punctuation">}</span><span class="token operator">></span>非父子传值<span class="token punctuation">,</span>给Two传值<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Two组件里面去接受</p><blockquote><p>利用PubSub.subscribe(“事件名”，（msg , data）=&gt; {})</p></blockquote><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> PubSub <span class="token keyword">from</span> <span class="token string">"pubsub-js"</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Two</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>      data<span class="token punctuation">:</span> <span class="token string">""</span>    <span class="token punctuation">}</span>    PubSub<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"evtBus"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>msg<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//事件名</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Hello word</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        data      <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span> data <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>        <span class="token punctuation">{</span>data<span class="token punctuation">}</span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>效果图</p><img src="./medias/loading2.gif" data-original="C:\Users\22284\AppData\Roaming\Typora\typora-user-images\image-20200217212510051.png" alt="image-20200217212510051" style="zoom:50%;" /><h3 id="自己封装eventBus"><a href="#自己封装eventBus" class="headerlink" title="自己封装eventBus"></a>自己封装eventBus</h3><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;react的父子组件传值大家都已经会了，今天我们来聊聊React的非父子组件传值，他的核心理念就是利用了发布订阅者模式来实现的，到最后，带大家手写一个发布订阅模式来实现react传值&lt;/p&gt;
&lt;h3 id=&quot;利用pubsub-js&quot;&gt;&lt;a href=&quot;#利用pubsub-j
      
    
    </summary>
    
    
      <category term="React" scheme="https://luckystart.xyz/categories/React/"/>
    
    
      <category term="React" scheme="https://luckystart.xyz/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>前端常见的攻击</title>
    <link href="https://luckystart.xyz/2020/02/16/qian-duan-chang-jian-de-gong-ji/"/>
    <id>https://luckystart.xyz/2020/02/16/qian-duan-chang-jian-de-gong-ji/</id>
    <published>2020-02-16T14:34:51.000Z</published>
    <updated>2020-02-16T14:39:47.837Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前端常见的攻击主要有 XSS     CSRF(跨站请求伪造)    点击劫持    中间人攻击</p></blockquote><h3 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h3><blockquote><p>攻击者将可执行代码注入到网页中 （总体分为持久型和非持久型）</p></blockquote><h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><blockquote><p>持久性就是将攻击的代码写入到数据库中，大量正常访问页面的用户都会受到攻击，如评论功能</p></blockquote><h4 id="非持久性"><a href="#非持久性" class="headerlink" title="非持久性"></a>非持久性</h4><blockquote><p>非持久性就是一般通过修改url参数的方式加入攻击代码，诱导用户访问链接而进行攻击<br> 利用转义字符将引号尖括号斜杠进行转义<br>  对于显示富文本来说不能利用转义，会把需要的格式也过滤掉，所以利用白名单的方式开启白名单有两种方式，第一：设置HTTP Header中Content-Security-Policy,让他只允许加载本站资源或者s协议图片</p></blockquote><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><blockquote><p>攻击者构造出一个后端请求地址，诱导用户点击发起请求，如果用户登录状态下，后端就以为是用户操作，从而进行相应的逻辑<br>防御： Get请求不对数据进行修改，不让第三方网站访问到用户Cookie 阻止第三方网站请求接口，每次请求时附带token</p></blockquote><h3 id="点击劫持攻击"><a href="#点击劫持攻击" class="headerlink" title="点击劫持攻击"></a>点击劫持攻击</h3><blockquote><p>需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击<br>X-FRAME-OPTIONS 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用 iframe 嵌套的点击劫持攻击。</p></blockquote><h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><blockquote><p>中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。<br>HTTPS 就可以用来防御中间人攻击，但是并不是说使用了 HTTPS 就可以高枕无忧了</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前端常见的攻击主要有 XSS     CSRF(跨站请求伪造)    点击劫持    中间人攻击&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;xss&quot;&gt;&lt;a href=&quot;#xss&quot; class=&quot;headerlink&quot; title=&quot;xss
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://luckystart.xyz/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://luckystart.xyz/tags/javascript/"/>
    
      <category term="原生" scheme="https://luckystart.xyz/tags/%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>js垃圾回收机制</title>
    <link href="https://luckystart.xyz/2020/02/16/js-la-ji-hui-shou-ji-zhi/"/>
    <id>https://luckystart.xyz/2020/02/16/js-la-ji-hui-shou-ji-zhi/</id>
    <published>2020-02-16T14:28:40.000Z</published>
    <updated>2020-02-16T14:33:02.578Z</updated>
    
    <content type="html"><![CDATA[<h3 id="回收机制介绍"><a href="#回收机制介绍" class="headerlink" title="回收机制介绍"></a>回收机制介绍</h3><p>v8 将内存(堆)分为新生代和老生代两部分</p><h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><blockquote><p>新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。</p><p>在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。</p></blockquote><h4 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h4><blockquote><p>老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。</p></blockquote><p>在讲算法前，先来说下什么情况下对象会出现在老生代空间中：</p><p>新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。<br>To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。<br>在老生代中，以下情况会先启动标记清除算法：</p><p>某一个空间没有分块的时候<br>空间中被对象超过一定限制<br>空间不能保证新生代中的对象移动到老生代中<br>在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。</p><p>在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行，你可以清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;回收机制介绍&quot;&gt;&lt;a href=&quot;#回收机制介绍&quot; class=&quot;headerlink&quot; title=&quot;回收机制介绍&quot;&gt;&lt;/a&gt;回收机制介绍&lt;/h3&gt;&lt;p&gt;v8 将内存(堆)分为新生代和老生代两部分&lt;/p&gt;
&lt;h4 id=&quot;新生代&quot;&gt;&lt;a href=&quot;#新生代&quot; 
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://luckystart.xyz/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://luckystart.xyz/tags/javascript/"/>
    
      <category term="原生" scheme="https://luckystart.xyz/tags/%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>函数的节流与防抖</title>
    <link href="https://luckystart.xyz/2020/02/16/han-shu-de-jie-liu-yu-fang-dou/"/>
    <id>https://luckystart.xyz/2020/02/16/han-shu-de-jie-liu-yu-fang-dou/</id>
    <published>2020-02-16T14:25:03.000Z</published>
    <updated>2020-02-16T14:27:54.526Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><p>例如 窗口调整  页面滚动  购物疯狂点击</p><blockquote><p>函数节流就是预定一个函数只有在大于等于执行周期时候才会执行，周期内调用不执行</p></blockquote><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span>wait<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> lastTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> nowTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nowTime <span class="token operator">-</span> lastTime <span class="token operator">></span> wait<span class="token punctuation">)</span><span class="token punctuation">{</span>      func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span>      lastTime <span class="token operator">=</span> nowTime    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h3><blockquote><p>函数防抖函数的防抖就是函数需要频繁触发情况时候，只有足够空闲的时间，才执行一次，</p><p>如  实时搜索  和 拖拽中</p></blockquote><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span>delay<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>    timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>delay<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;函数节流&quot;&gt;&lt;a href=&quot;#函数节流&quot; class=&quot;headerlink&quot; title=&quot;函数节流&quot;&gt;&lt;/a&gt;函数节流&lt;/h3&gt;&lt;p&gt;例如 窗口调整  页面滚动  购物疯狂点击&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;函数节流就是预定一个函数只有在大于等于执
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://luckystart.xyz/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://luckystart.xyz/tags/javascript/"/>
    
      <category term="前端" scheme="https://luckystart.xyz/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Http和Https那些事</title>
    <link href="https://luckystart.xyz/2020/02/16/http-he-https-na-xie-shi/"/>
    <id>https://luckystart.xyz/2020/02/16/http-he-https-na-xie-shi/</id>
    <published>2020-02-16T14:18:42.000Z</published>
    <updated>2020-02-17T06:25:41.245Z</updated>
    
    <content type="html"><![CDATA[<h3 id="谈谈http和https的区别"><a href="#谈谈http和https的区别" class="headerlink" title="谈谈http和https的区别"></a>谈谈http和https的区别</h3><blockquote><p>http默认端口是80，https默认端口是443<br>http是超文本传输协议，信息是明文传输，客户端和服务端都无法验证对方的身份，https是由ssl+http协议构建的可进行加密传输身份认证的网络协议<br>http效率更高，https安全性高</p></blockquote><h3 id="常见的http状态码"><a href="#常见的http状态码" class="headerlink" title="常见的http状态码"></a>常见的http状态码</h3><blockquote><p>200 请求成功  202 服务器已经接受了请求，但是还没有对其进行处理 204服务器成功处理请求但未返回内容<br>301 永久重定向 请求的网页已被永久移动到新位置，服务器返回此响应时，会自动将请求者转到新位置<br>302 临时重定向 服务器正从不同的位置网页响应请求，但请求者仍然可以使用原有位置进行请求，如新浪<br>304 代表缓存<br>401 身份验证错误，未授权<br>403 服务器拒绝请求<br>404 未找到<br>500 服务器错误<br>501 服务器无法识别，不具备完成请求的功能<br>503 服务不可用</p></blockquote><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><blockquote><p>发送端发送一个带有SYN的数据包给对方，<br>接收端收到后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示收到了<br>发送端再回传一个ACK标志的数据包，握手结束</p></blockquote><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><blockquote><p>如主动关闭方是客户端，客户端发送一个FIN用来关闭与服务端的数据传输，客户端进入FIN_WAIT_1状态<br>服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入CLOSE_WAIT状态<br>服务端发送一个FIN，用来关闭客户端和服务端的数据传送<br>客户端收到FIN后，发送一个ACK给服务端，服务端进入关闭状态，完成四次挥手</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;谈谈http和https的区别&quot;&gt;&lt;a href=&quot;#谈谈http和https的区别&quot; class=&quot;headerlink&quot; title=&quot;谈谈http和https的区别&quot;&gt;&lt;/a&gt;谈谈http和https的区别&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;http默
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://luckystart.xyz/categories/javascript/"/>
    
    
      <category term="浏览器" scheme="https://luckystart.xyz/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="javascript" scheme="https://luckystart.xyz/tags/javascript/"/>
    
      <category term="计算机基础" scheme="https://luckystart.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>初遇Vue</title>
    <link href="https://luckystart.xyz/2020/02/16/chu-yu-vue/"/>
    <id>https://luckystart.xyz/2020/02/16/chu-yu-vue/</id>
    <published>2020-02-16T13:30:24.000Z</published>
    <updated>2020-02-17T06:24:45.792Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>Vue是一套用于构建用户界面的<strong>渐进式框架</strong>。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与<a href="https://cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" rel="noopener">现代化的工具链</a>以及各种<a href="https://github.com/vuejs/awesome-vue#libraries--plugins" target="_blank" rel="noopener">支持类库</a>结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 </p></blockquote><h3 id="v-model原理"><a href="#v-model原理" class="headerlink" title="v-model原理"></a>v-model原理</h3><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>div id <span class="token operator">=</span> <span class="token string">"app"</span><span class="token operator">></span>     <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> <span class="token punctuation">:</span>value<span class="token operator">=</span><span class="token string">"message"</span> @input<span class="token operator">=</span><span class="token string">"message = $event.target.value"</span><span class="token operator">></span>      <span class="token punctuation">{</span><span class="token punctuation">{</span>message<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>     <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        message<span class="token punctuation">:</span><span class="token string">''</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// change(event){</span>        <span class="token comment" spellcheck="true">//   console.log(event)</span>        <span class="token comment" spellcheck="true">//   this.message = event.target.value</span>        <span class="token comment" spellcheck="true">// }</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Vue是一套用于构建用户界面的&lt;strong&gt;渐进式框架&lt;/strong&gt;。与其它大型框架不同的是，Vue 被设计
      
    
    </summary>
    
    
      <category term="Vue" scheme="https://luckystart.xyz/categories/Vue/"/>
    
    
      <category term="vue" scheme="https://luckystart.xyz/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://luckystart.xyz/2020/02/14/hello-world/"/>
    <id>https://luckystart.xyz/2020/02/14/hello-world/</id>
    <published>2020-02-14T05:54:19.503Z</published>
    <updated>2020-02-14T05:54:19.503Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浏览器缓存的那些事</title>
    <link href="https://luckystart.xyz/2020/02/14/qian-duan-da-za-hui-1/"/>
    <id>https://luckystart.xyz/2020/02/14/qian-duan-da-za-hui-1/</id>
    <published>2020-02-14T01:25:16.000Z</published>
    <updated>2020-02-16T13:55:25.955Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浏览器缓存能做什么"><a href="#浏览器缓存能做什么" class="headerlink" title="浏览器缓存能做什么"></a>浏览器缓存能做什么</h3><p>浏览器缓存可以帮助我们在网路请求和浏览器响应中优化性能</p><h3 id="浏览器缓存的位置"><a href="#浏览器缓存的位置" class="headerlink" title="浏览器缓存的位置"></a>浏览器缓存的位置</h3><p>浏览器在缓存位置上有四种，各自有优先级依次查找缓存没有命中的时候，才会去请求网路</p><h4 id="1-Service-Worker"><a href="#1-Service-Worker" class="headerlink" title="1.Service Worker"></a>1.Service Worker</h4><blockquote><p>运行在浏览器背后的独立线程,使用这个传输协议必须为HTTPS。实现缓存功能分为三个步骤，首先注册service Worker 然后监听到install事件以后就可以缓存需要的文件，在下次用户访问的时候就可以通过拦截请求的方式查询是否有缓存，有缓存就读取缓存，否则请求数据</p></blockquote><h4 id="2-memory-Cache"><a href="#2-memory-Cache" class="headerlink" title="2. memory Cache"></a>2. memory Cache</h4><blockquote><p>内存缓存 虽然读取高效，可是缓存持续性短，会随着进程的释放而释放，一般来说，大文件大概率不存在内存中，当系统内存使用效率高，文件优先存储到硬盘</p></blockquote><h4 id="3-DisK-cache"><a href="#3-DisK-cache" class="headerlink" title="3. DisK cache"></a>3. DisK cache</h4><blockquote><p>硬盘内存 读取速度慢，什么都可以存储到硬盘中，会根据http Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求 </p></blockquote><h4 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h4><blockquote><p>以上三种缓存没有命中，才会被使用，并且缓存时间也很短暂，只在会话（session）中存在，一旦会话结束就被释放</p></blockquote><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p> 通过设置HTTP Header 来实现  分为强缓存和协商缓存</p><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><blockquote><p>强缓存可以通过设置两种HTTP Header 实现  Expires 和Cache-Control 强缓存表示在缓存期间不需要请求，State Code 为 200<br>Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效<br>Cache-control 可以在请求头或者响应头中设置，可以配合多个指令配合使用，如 public private max-age=30 s-maxage=30 no-store  no-cache(资源被缓存，但会立即失效)</p></blockquote><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><blockquote><p>如果缓存过期了，就需要发起请求验证资源是否有更新，可以设置last-Modified 和ETag</p><p>如果什么缓存策略都没有设置，浏览器会采用一个启发式的算法，通常会取响应头中的date减去last-Modified值的10%作为缓存时间<br>对于频繁变动的资源，首先需要使用 Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p></blockquote><h3 id="如何防止浏览器缓存"><a href="#如何防止浏览器缓存" class="headerlink" title="如何防止浏览器缓存"></a>如何防止浏览器缓存</h3><blockquote><p>1.在利用ajax请求的时候，在url地址的问号后面加一个时间戳参数，防止浏览器缓存<br>2.使用meta语法 <meta http-equiv="Cache-Control" content="no-cache"><br>3.设置请求头： “Cache-Control”, “no-cache”</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;浏览器缓存能做什么&quot;&gt;&lt;a href=&quot;#浏览器缓存能做什么&quot; class=&quot;headerlink&quot; title=&quot;浏览器缓存能做什么&quot;&gt;&lt;/a&gt;浏览器缓存能做什么&lt;/h3&gt;&lt;p&gt;浏览器缓存可以帮助我们在网路请求和浏览器响应中优化性能&lt;/p&gt;
&lt;h3 id=&quot;浏览
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://luckystart.xyz/categories/javascript/"/>
    
    
      <category term="浏览器" scheme="https://luckystart.xyz/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="javascript" scheme="https://luckystart.xyz/tags/javascript/"/>
    
  </entry>
  
</feed>
